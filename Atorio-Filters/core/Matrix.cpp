#include "Matrix.hpp"

mat4 mat4::operator = (mat4 const &m) {
	for (int i = 0; i < 4; i++)
		for (int j = 0; j < 4; j++)
			this->c[i][j] = m.c[i][j];
	return (*this);
}

mat4 mat4::operator - () {
	mat4 d;
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++)
            d.c[i][j] = -this->c[i][j];
	}
	return d;
}

mat4 mat4::operator + (mat4 const &m) {
	mat4 d;
	for (int i = 0; i < 4; i++)
        for (int j = 0; j < 4; j++)
			d.c[i][j] = this->c[i][j] + m.c[i][j];
	return d;
}

mat4 mat4::operator - (mat4 const &m) {
	mat4 d;
	for (int i = 0; i < 4; i++)
        for (int j = 0; j < 4; j++)
			d.c[i][j] = this->c[i][j] - m.c[i][j];
	return d;
}

mat4 mat4::operator * (mat4 const &m) {
	mat4 d;
	for (int r = 0; r < 4; r++)
		for (int c = 0; c < 4; c++) {
			d.c[r][c] = 0;
			for (int i = 0; i < 4; i++)
				d.c[r][c] += this->c[r][i] * m.c[i][c];
		}
	return d;
}

vec4 mat4::operator * (vec4 const& v) {
	vec4 r;
	r.x = v.x * c[0][0] + v.y * c[0][1] + v.z * c[0][2] + v.w * c[0][3];
	r.y = v.x * c[1][0] + v.y * c[1][1] + v.z * c[1][2] + v.w * c[1][3];
	r.z = v.x * c[2][0] + v.y * c[2][1] + v.z * c[2][2] + v.w * c[2][3];
	r.w = v.x * c[3][0] + v.y * c[3][1] + v.z * c[3][2] + v.w * c[3][3];
	return r;
}

mat4 mat4::operator * (float f) {
	mat4 d;
	for (int i = 0; i < 4; i++)
        for (int j = 0; j < 4; j++)
			d.c[i][j] = this->c[i][j] * f;
	return d;
}

mat4 mat4::operator / (float f) {
	mat4 d;
	for (int i = 0; i < 4; i++)
        for (int j = 0; j < 4; j++)
			d.c[i][j] = this->c[i][j] / f;
	return d;
}

float mat4::det()
{
	return
		c[0][3] * c[1][2] * c[2][1] * c[3][0] - c[0][2] * c[1][3] * c[2][1] * c[3][0] -
		c[0][3] * c[1][1] * c[2][2] * c[3][0] + c[0][1] * c[1][3] * c[2][2] * c[3][0] +
		c[0][2] * c[1][1] * c[2][3] * c[3][0] - c[0][1] * c[1][2] * c[2][3] * c[3][0] -
		c[0][3] * c[1][2] * c[2][0] * c[3][1] + c[0][2] * c[1][3] * c[2][0] * c[3][1] +
		c[0][3] * c[1][0] * c[2][2] * c[3][1] - c[0][0] * c[1][3] * c[2][2] * c[3][1] -
		c[0][2] * c[1][0] * c[2][3] * c[3][1] + c[0][0] * c[1][2] * c[2][3] * c[3][1] +
		c[0][3] * c[1][1] * c[2][0] * c[3][2] - c[0][1] * c[1][3] * c[2][0] * c[3][2] -
		c[0][3] * c[1][0] * c[2][1] * c[3][2] + c[0][0] * c[1][3] * c[2][1] * c[3][2] +
		c[0][1] * c[1][0] * c[2][3] * c[3][2] - c[0][0] * c[1][1] * c[2][3] * c[3][2] -
		c[0][2] * c[1][1] * c[2][0] * c[3][3] + c[0][1] * c[1][2] * c[2][0] * c[3][3] +
		c[0][2] * c[1][0] * c[2][1] * c[3][3] - c[0][0] * c[1][2] * c[2][1] * c[3][3] -
		c[0][1] * c[1][0] * c[2][2] * c[3][3] + c[0][0] * c[1][1] * c[2][2] * c[3][3];
}

mat4 mat4::inverse() {
	mat4 inv;

	inv.c[0][0] =  c[1][1] * c[2][2] * c[3][3] - c[1][1] * c[2][3] * c[3][2] - c[2][1] * c[1][2] * c[3][3] + c[2][1] * c[1][3] * c[3][2] + c[3][1] * c[1][2] * c[2][3] - c[3][1] * c[1][3] * c[2][2];
	inv.c[0][1] = -c[0][1] * c[2][2] * c[3][3] + c[0][1] * c[2][3] * c[3][2] + c[2][1] * c[0][2] * c[3][3] - c[2][1] * c[0][3] * c[3][2] - c[3][1] * c[0][2] * c[2][3] + c[3][1] * c[0][3] * c[2][2];
	inv.c[0][2] =  c[0][1] * c[1][2] * c[3][3] - c[0][1] * c[1][3] * c[3][2] - c[1][1] * c[0][2] * c[3][3] + c[1][1] * c[0][3] * c[3][2] + c[3][1] * c[0][2] * c[1][3] - c[3][1] * c[0][3] * c[1][2];
	inv.c[0][3] = -c[0][1] * c[1][2] * c[2][3] + c[0][1] * c[1][3] * c[2][2] + c[1][1] * c[0][2] * c[2][3] - c[1][1] * c[0][3] * c[2][2] - c[2][1] * c[0][2] * c[1][3] + c[2][1] * c[0][3] * c[1][2];
	inv.c[1][0] = -c[1][0] * c[2][2] * c[3][3] + c[1][0] * c[2][3] * c[3][2] + c[2][0] * c[1][2] * c[3][3] - c[2][0] * c[1][3] * c[3][2] - c[3][0] * c[1][2] * c[2][3] + c[3][0] * c[1][3] * c[2][2];
	inv.c[1][1] =  c[0][0] * c[2][2] * c[3][3] - c[0][0] * c[2][3] * c[3][2] - c[2][0] * c[0][2] * c[3][3] + c[2][0] * c[0][3] * c[3][2] + c[3][0] * c[0][2] * c[2][3] - c[3][0] * c[0][3] * c[2][2];
	inv.c[1][2] = -c[0][0] * c[1][2] * c[3][3] + c[0][0] * c[1][3] * c[3][2] + c[1][0] * c[0][2] * c[3][3] - c[1][0] * c[0][3] * c[3][2] - c[3][0] * c[0][2] * c[1][3] + c[3][0] * c[0][3] * c[1][2];
	inv.c[1][3] =  c[0][0] * c[1][2] * c[2][3] - c[0][0] * c[1][3] * c[2][2] - c[1][0] * c[0][2] * c[2][3] + c[1][0] * c[0][3] * c[2][2] + c[2][0] * c[0][2] * c[1][3] - c[2][0] * c[0][3] * c[1][2];
	inv.c[2][0] =  c[1][0] * c[2][1] * c[3][3] - c[1][0] * c[2][3] * c[3][1] - c[2][0] * c[1][1] * c[3][3] + c[2][0] * c[1][3] * c[3][1] + c[3][0] * c[1][1] * c[2][3] - c[3][0] * c[1][3] * c[2][1];
	inv.c[2][1] = -c[0][0] * c[2][1] * c[3][3] + c[0][0] * c[2][3] * c[3][1] + c[2][0] * c[0][1] * c[3][3] - c[2][0] * c[0][3] * c[3][1] - c[3][0] * c[0][1] * c[2][3] + c[3][0] * c[0][3] * c[2][1];
	inv.c[2][2] =  c[0][0] * c[1][1] * c[3][3] - c[0][0] * c[1][3] * c[3][1] - c[1][0] * c[0][1] * c[3][3] + c[1][0] * c[0][3] * c[3][1] + c[3][0] * c[0][1] * c[1][3] - c[3][0] * c[0][3] * c[1][1];
	inv.c[2][3] = -c[0][0] * c[1][1] * c[2][3] + c[0][0] * c[1][3] * c[2][1] + c[1][0] * c[0][1] * c[2][3] - c[1][0] * c[0][3] * c[2][1] - c[2][0] * c[0][1] * c[1][3] + c[2][0] * c[0][3] * c[1][1];
	inv.c[3][0] = -c[1][0] * c[2][1] * c[3][2] + c[1][0] * c[2][2] * c[3][1] + c[2][0] * c[1][1] * c[3][2] - c[2][0] * c[1][2] * c[3][1] - c[3][0] * c[1][1] * c[2][2] + c[3][0] * c[1][2] * c[2][1];
	inv.c[3][1] =  c[0][0] * c[2][1] * c[3][2] - c[0][0] * c[2][2] * c[3][1] - c[2][0] * c[0][1] * c[3][2] + c[2][0] * c[0][2] * c[3][1] + c[3][0] * c[0][1] * c[2][2] - c[3][0] * c[0][2] * c[2][1];
	inv.c[3][2] = -c[0][0] * c[1][1] * c[3][2] + c[0][0] * c[1][2] * c[3][1] + c[1][0] * c[0][1] * c[3][2] - c[1][0] * c[0][2] * c[3][1] - c[3][0] * c[0][1] * c[1][2] + c[3][0] * c[0][2] * c[1][1];
	inv.c[3][3] =  c[0][0] * c[1][1] * c[2][2] - c[0][0] * c[1][2] * c[2][1] - c[1][0] * c[0][1] * c[2][2] + c[1][0] * c[0][2] * c[2][1] + c[2][0] * c[0][1] * c[1][2] - c[2][0] * c[0][2] * c[1][1];

	float rdet = 1 / (c[0][0] * inv.c[0][0] + c[0][1] * inv.c[1][0] + c[0][2] * inv.c[2][0] + c[0][3] * inv.c[3][0]);
	for (int i = 0; i < 16; i++) inv.c[i >> 2][i & 3] *= rdet;
	return inv;
}